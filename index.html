<!DOCTYPE html>
<html>
<head>
    <title>手势粒子倒计时</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <style>
        body { margin: 0; background: #000; overflow: hidden; color: white; }
        #video_input { display: none; }
        #canvas_output { width: 100vw; height: 100vh; object-fit: cover; }
        #info { position: absolute; top: 20px; left: 20px; font-family: sans-serif; color: rgba(255,255,255,0.5); }
    </style>
</head>
<body>
    <div id="info">请对着镜头比划数字 5 -> 1</div>
    <video id="video_input"></video>
    <canvas id="canvas_output"></canvas>

<script>
const videoElement = document.getElementById('video_input');
const canvasElement = document.getElementById('canvas_output');
const canvasCtx = canvasElement.getContext('2d');

let currentNumber = 5;
let particles = [];
let targetPoints = [];
const particleCount = 1200; // 粒子数量

// 1. 初始化粒子类
class Particle {
    constructor() {
        this.x = Math.random() * window.innerWidth;
        this.y = Math.random() * window.innerHeight;
        this.destX = this.x;
        this.destY = this.y;
        this.vx = 0;
        this.vy = 0;
        this.friction = 0.85; // 阻力
        this.ease = 0.15;     // 缓动系数
        this.color = `hsla(${Math.random() * 360}, 100%, 70%, 0.8)`;
    }

    update() {
        // 计算向目标的拉力
        this.vx += (this.destX - this.x) * this.ease;
        this.vy += (this.destY - this.y) * this.ease;
        this.vx *= this.friction;
        this.vy *= this.friction;
        this.x += this.vx;
        this.y += this.vy;
    }

    draw() {
        canvasCtx.fillStyle = this.color;
        canvasCtx.beginPath();
        canvasCtx.arc(this.x, this.y, 1.8, 0, Math.PI * 2);
        canvasCtx.fill();
    }
}

// 2. 采样数字坐标
function sampleNumber(num) {
    const tempCanvas = document.createElement('canvas');
    const tCtx = tempCanvas.getContext('2d');
    tempCanvas.width = window.innerWidth;
    tempCanvas.height = window.innerHeight;
    
    tCtx.font = "bold 500px Arial";
    tCtx.textAlign = "center";
    tCtx.textBaseline = "middle";
    tCtx.fillText(num, tempCanvas.width / 2, tempCanvas.height / 2);

    const imageData = tCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height).data;
    const newTargets = [];
    // 隔行采样以提升性能
    for (let y = 0; y < tempCanvas.height; y += 8) {
        for (let x = 0; x < tempCanvas.width; x += 8) {
            const alpha = imageData[(y * tempCanvas.width + x) * 4 + 3];
            if (alpha > 128) {
                newTargets.push({x, y});
            }
        }
    }
    return newTargets;
}

// 3. 宇宙大爆炸效果
function triggerBigBang() {
    particles.forEach(p => {
        const angle = Math.random() * Math.PI * 2;
        const force = Math.random() * 100;
        p.destX = p.x + Math.cos(angle) * force * 10;
        p.destY = p.y + Math.sin(angle) * force * 10;
        p.ease = 0.02; // 爆炸时更慢更松散
    });
}

// 4. 手势识别逻辑
function onResults(results) {
    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        // 简易手指计数算法
        const count = [8, 12, 16, 20].reduce((acc, tip) => {
            return landmarks[tip].y < landmarks[tip - 2].y ? acc + 1 : acc;
        }, landmarks[4].x < landmarks[3].x ? 1 : 0);

        if (count === currentNumber && currentNumber > 0) {
            targetPoints = sampleNumber(currentNumber);
            // 分配目标点
            for (let i = 0; i < particles.length; i++) {
                const target = targetPoints[i % targetPoints.length];
                particles[i].destX = target.x;
                particles[i].destY = target.y;
            }
            currentNumber--;
            if (currentNumber === 0) {
                setTimeout(triggerBigBang, 800);
            }
        }
    }

    // 渲染粒子
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    particles.forEach(p => {
        p.update();
        p.draw();
    });
}

// 初始化
function init() {
    canvasElement.width = window.innerWidth;
    canvasElement.height = window.innerHeight;
    for (let i = 0; i < particleCount; i++) particles.push(new Particle());

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    const camera = new Camera(videoElement, {
        onFrame: async () => await hands.send({image: videoElement}),
        width: 1280, height: 720
    });
    camera.start();
}

init();
</script>
</body>
</html>